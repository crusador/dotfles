" Vundle
    set rtp+=~/.vim/bundle/vundle/
    call vundle#rc()

" Bundles
    Bundle "nanotech/jellybeans.vim"
    Bundle "tomtom/tlib_vim"
    Bundle "MarcWeber/vim-addon-mw-utils"
    Bundle "aperezdc/vim-template"
    Bundle "garbas/vim-snipmate"
    Bundle "godlygeek/tabular"
    Bundle "honza/vim-snippets"
    Bundle "itchyny/lightline.vim"
    Bundle "Lokaltog/vim-easymotion"
    Bundle "rstacruz/sparkup"
    Bundle "scrooloose/nerdtree"
    Bundle "scrooloose/syntastic"
    Bundle "tomtom/tcomment_vim"
    Bundle "tpope/vim-abolish"
    Bundle "tpope/vim-fugitive"
    Bundle "tpope/vim-repeat"
    Bundle "tpope/vim-surround"
    Bundle "tpope/vim-unimpaired"
    Bundle "airblade/vim-gitgutter"
    Bundle "matchit.zip"
    Bundle "Shougo/unite.vim"
    Bundle "nathanaelkane/vim-indent-guides"
    Bundle "sk1418/Join"
    Bundle "osyo-manga/vim-anzu"
    Bundle "Raimondi/delimitMate"

" Functions
    " Lightline functions
        " Override lightline's method to return 'n+' when there are 'n' modified buffers in a tab
        function! lightline#tab#modified(n)
            let winnr = tabpagewinnr(a:n)
            let buflist = tabpagebuflist(a:n)
            let m = 0 " &modified counter
            " loop through each buffer in a tab
            for b in buflist
                " check and ++ tab's &modified count
                if getbufvar( b, "&modified" )
                let m += 1
                endif
            endfor
            return (m > 0) ? (m > 1) ? m.'+' : '+' : gettabwinvar(a:n, winnr, '&modifiable') ? '' : '-'
        endfunction

        function! LightlineModified()
            if &filetype == "help"
                return ""
            elseif &modified
                return "+"
            elseif &modifiable
                return ""
            else
                return ""
            endif
        endfunction

        function! LightlineReadonly()
            if &filetype == "help"
                return ""
            elseif &readonly
                return "x"
            else
                return ""
            endif
        endfunction

        function! LightlineFugitive()
            try
                if expand('%:t') !~? 'NERD' && exists('*fugitive#head')
                let mark = 'Y '  " edit here for cool mark
                let _ = fugitive#head()
                return strlen(_) ? mark._ : ''
                endif
            catch
            endtry
            return ''
        endfunction

        function! LightlineFilename()
            let fname = expand('%:t')
            return fname =~ 'NERD_tree' ? '' :
                    \ ('' != fname ? fname : '[No Name]')
        endfunction

        function! LightlineFileDir()
            let dirname = expand('%:p:h')
            let fname = expand('%:t')
            return winwidth(0) < 80 ? '' :
                    \ fname =~ 'NERD_tree' ? '' :
                    \ ('' != fname ? dirname : '')
        endfunction


        function! LightlineMode()
            let fname = expand('%:t')
            return fname =~ 'NERD_tree' ? 'NERDTree' :
                \ winwidth(0) > 60 ? lightline#mode() : ''
        endfunction

        function! LightlineFileencoding()
            return winwidth(0) > 70 ? (strlen(&fenc) ? &fenc : &enc) : ''
        endfunction

        function! LightlineFileformat()
            return winwidth(0) > 70 ? &fileformat : ''
        endfunction

        function! LightlineFiletype()
            return winwidth(0) > 70 ? (strlen(&filetype) ? &filetype : 'no ft') : ''
        endfunction

    " Return the regex to tabularize the selected data into two columns with the provided delimiter
    function! Tabularize2ColumnsRegex()
        call inputsave()
        let delim=input("Enter the delimiting string: ")
        call inputrestore()
        return "^.{-}\\zs".delim
    endfunction

" Colors
    colorscheme jellybeans

" Appearance
    set laststatus=2
    set cul                         " Highlight cursor line

    " lightline configurations
        let g:lightline = {
                    \ 'colorscheme': 'default',
                    \ 'active': {
                    \   'left': [ [ 'mode', 'paste' ], [ 'fugitive', 'readonly', 'filename', 'modified' ] ],
                    \   'right': [ [ 'lineinfo' ], ['percent'], [ 'filedir', 'fileformat', 'fileencoding', 'filetype' ] ]
                    \ },
                    \ 'component_function': {
                    \   'fugitive'     : 'LightlineFugitive',
                    \   'readonly'     : 'LightlineReadonly',
                    \   'modified'     : 'LightlineModified',
                    \   'filename'     : 'LightlineFilename',
                    \   'fileencoding' : 'LightlineFileencoding',
                    \   'fileformat'   : 'LightlineFileformat',
                    \   'filetype'     : 'LightlineFiletype',
                    \   'filedir'      : 'LightlineFileDir',
                    \   'mode'         : 'LightlineMode'
                    \ },
                    \ 'subseparator': { 'left': "|", 'right': "|" }
                    \ }

" Maps
    " Standard keys remaps
        nmap n <Plug>(anzu-n-with-echo)
        nmap N <Plug>(anzu-N-with-echo)
        nmap * <Plug>(anzu-star-with-echo)
        nmap <Esc><Esc> <Plug>(anzu-clear-search-status)
        nmap # <Plug>(anzu-sharp-with-echo)

    " Leader key maps
        vmap  <leader>t  ;Tabularize /\v
        vmap  <leader>T  ;Tabularize /\v=Tabularize2ColumnsRegex()<CR><CR>

        " Unite maps
            map   <leader>ub  ;Unite buffer<cr>
            map   <leader>uf  ;Unite file<CR>
            map   <leader>ut  ;Unite tab<CR>
            map   <leader>uu  ;Unite buffer file tab<CR>

    " 'g' key maps
        map gn ;NERDTree<CR>
        map gN ;NERDTree<CR>

" Plugin Settings
    let g:EasyMotion_leader_key = '<Leader>'
    let g:sparkupNextMapping = '<c-y>'
    let g:indent_guides_start_level = 2
    let g:indent_guides_enable_on_vim_startup = 1
    let NERDTreeIgnore = ['\.pyc$']
